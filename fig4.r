#  Fig 4 to contain i) parameters estimated from basic negbin model fitted to simulated data
# to show how components of R are estimated when data are partially observed. 
# So panel A to show proportion of hospital acquired infections observed, versus on y axis estimate (with a line for the
# R vakue for simulation. Do For all 6 component  R values but varying proportion of infection observed)
# For panel B, do a heatmap where x-axis is detection prob, y is the parameter estimate and z (colour or contour)
# is the R estimate

draw_generation_interval<-function(n){
  # n is the number of generation intervals to draw
  # For now, base generation time estimates on Ferretti  (Science 2020)
  # Weibull shape = 2.826
  w_shape<-2.826
  # Weibull scale = 5.665
  w_scale<- 5.665
  gen_int<-rweibull(n,shape = w_shape,scale=w_scale)
  #  gen_int<-rep(7,n)
  return(gen_int)
}
sim_data_for_one_trust<-function(community_onset_admissions, hcws_infected_in_community){
  # community_onset_admissions is a vector with length equal to the number of days to simulate
  # ith element contains number of patients with community onset covid (still infectious) admitted on day i
  # hcws_infected_in_community is similar for infections in HCWs acquired in the community
  #function simulated number of days equal to length(community_onset_admissions)
  # and returns a a dataframe holding number of different of infctions in the different groups on each day
  MAXGI<-20  #max permitted generation interval
  days<-length(community_onset_admissions)
  ha_infections_P <-rep(0,days + MAXGI ) #hospital acquired infections in patients
  ha_infections_H <-rep(0,days + MAXGI ) #hospital acquired infections in HCWs
  
  for(i in 1:days){
    # total secondary cases from community onset admissions
    if(community_onset_admissions[i]>0){
      y_C <-rnbinom(community_onset_admissions[i],mu=R_CH + R_CP, size=k_C)
      if(sum(y_C)>0){
        gis<-draw_generation_interval(sum(y_C))
        patient_infections<-rbinom(sum(y_C),1,R_CP/(R_CH+R_CP))
        HCW_infections<-1-patient_infections
        for(j in 1:length(gis)){
          if(patient_infections[j]) ha_infections_P[i+gis[j]]<- ha_infections_P[i+gis[j]] +1
          if(HCW_infections[j]) ha_infections_H[i+gis[j]]<- ha_infections_H[i+gis[j]] +1
        }  # end for
      }# end if(sum_ycC) 
    }# end if(community_onset_admissions)
    
    # total secondary cases from community transmission to HCWs
    if(hcws_infected_in_community[i]>0){
      y_C <-rnbinom(hcws_infected_in_community[i],mu=R_HH + R_HP, size=k_H)
      if(sum(y_C)>0){
        gis<-draw_generation_interval(sum(y_C))
        patient_infections<-rbinom(sum(y_C),1,R_HP/(R_HH+R_HP))
        HCW_infections<-1-patient_infections
        for(j in 1:length(gis)){
          if(patient_infections[j]) ha_infections_P[i+gis[j]]<- ha_infections_P[i+gis[j]] +1
          if(HCW_infections[j]) ha_infections_H[i+gis[j]]<- ha_infections_H[i+gis[j]] +1
        }  # end for
      }# end if(sum_ycC) 
    }# end if(community_onset_admissions)
    
    # total secondary cases from  patients who acquired infection in hospital
    if(ha_infections_P[i]>0){
      y_C <-rnbinom(ha_infections_P[i],mu=R_PH + R_PP, size=k_P)
      if(sum(y_C)>0){
        gis<-draw_generation_interval(sum(y_C))
        patient_infections<-rbinom(sum(y_C),1,R_PP/(R_PH+R_PP))
        HCW_infections<-1-patient_infections
        for(j in 1:length(gis)){
          if(patient_infections[j]) ha_infections_P[i+gis[j]]<- ha_infections_P[i+gis[j]] +1
          if(HCW_infections[j]) ha_infections_H[i+gis[j]]<- ha_infections_H[i+gis[j]] +1
        }  # end for
      }# end if(sum_ycC) 
    }# end if(community_onset_admissions)
    
    # total secondary cases from  HCWs who acquired infection in this hospital
    if(ha_infections_H[i]>0){
      y_C <-rnbinom(ha_infections_H[i],mu=R_HH + R_HP, size=k_H)
      if(sum(y_C)>0){
        gis<-draw_generation_interval(sum(y_C))
        patient_infections<-rbinom(sum(y_C),1,R_HP/(R_HH+R_HP))
        HCW_infections<-1-patient_infections
        for(j in 1:length(gis)){
          if(patient_infections[j]) ha_infections_P[i+gis[j]]<- ha_infections_P[i+gis[j]] +1
          if(HCW_infections[j]) ha_infections_H[i+gis[j]]<- ha_infections_H[i+gis[j]] +1
        }  # end for
      }# end if(sum_ycC) 
    }# end if(community_onset_admissions)
  }
  
  
  l<-length(hcws_infected_in_community)
  total_infections_H<-ha_infections_H[1:l]
  total_infections_H<- total_infections_H +hcws_infected_in_community
  results<-data.frame(ca_P=community_onset_admissions[1:l],ha_P=ha_infections_P[1:l], ha_H=ha_infections_H[1:l], total_H=total_infections_H)  
  return(results)
}

gen_observed_data<-function(rawdata, prob_observing_patient_infection, prob_observing_hcw_infection){
  #rawdata is a adataframe generated by sim_data_for_one_trust
  #prob_observing_patient_infection and prob_observing_hcw_infection correspond to p_P and p_H
  n<-dim(rawdata)[1]
  obs_ha_P<-rbinom(rep(1,n), rawdata$ha_P,prob_observing_patient_infection) 
  obs_ha_H<-rbinom(rep(1,n), rawdata$ha_H,prob_observing_hcw_infection)
  obs_total_H<-rbinom(rep(1,n), rawdata$total_H,prob_observing_hcw_infection)
  obs_ca_P<-rawdata$ca_P   #i.e. for now assume that all those patients admitted with covid are detected 
  # (not unreasonable for periods where admission screening was in place)
  results<-data.frame(o_ca_P= obs_ca_P,o_ha_P=obs_ha_P, o_ha_H=obs_ha_H, o_total_H=obs_total_H)  
  return(results)
}

gen_wkly_total<-function(daily.data, daysinweek=7){
  #function takes a data frame containing daily data,daily.data assumed to be output from gen_observed_data
  #and returns weekly aggregates (i.e. total for each variable for each "week")
  # by default  assumes 7 days in a week, but allows for other possibilities so we can, for example, generate 
  # aggregates at 5 day intervals, which could better reflect the generation interval
  l<- dim(daily.data)[1]
  m<-dim(daily.data)[2]
  daily.data$wk<- 1+(0:(l-1))%/%daysinweek   # adds a week number field, wk
  result<-aggregate(daily.data[,1:m], by=list(week=daily.data$wk), sum, simplify=TRUE)
  return(result)
}


# First don a plot keeping regression parameters constant but varying detection probabilities 
# Parameters for regression model

R_HH <- 0.5 #mean secondary cases amongst HCWs per case in a HCW
R_HP <- 0.2 #mean secondary cases amongst in-patients per case in a HCW
R_HC <-  NA #not currently used. mean secondary cases in community  per case in a HCW

R_PH <- 0.2 #mean secondary cases amongst HCWs per nosocomial case in a patient
R_PP <- 0.6 #mean secondary cases amongst in-patients per nosocomial case in a patient
R_PC <-  NA #not currently used. mean secondary cases in community  per nosocomial case in a patient

R_CH <- 0.05 #mean secondary cases amongst HCWs via hospital spread per admitted community acquired case in a patient
R_CP <- 0.05 #mean secondary cases amongst in-patients per admitted community acquired case
R_CC <-  NA #not currently used. mean secondary cases in community  per admitted community acquired case



# then  need detection probabilities

p_P<- 1# probability that a patient infected in hospital is detected and recorded as a nosocomial case
p_H <-1  # probability that an infected HCW is detected
p_C <- 1 # probablity that a patient admitted with community onset COVID-19 is detected and recorded in the data

# Negin k values
#  in general this varies over time and space but Max Lau 2020 PNAS paper (Lau, Grenfell, ...Lopman)
# suggests values of 0.5 are reasonable https://www.pnas.org/content/117/36/22430.short

k_C <- 0.5 # clustering parameter for negbin distribution for  secondary cases from CA patients
k_P <- 0.5 # clustering parameter for negbin distribution for  secondary cases from HA patients
k_H <- 0.5 # clustering parameter for negbin distribution for  secondary cases from HCWs
community_onset_admissions<-rep(1,1000)
community_onset_admissions<-rpois(1000,0.5)
a<-community_onset_admissions
b<-rep(0,1000)
b<-rpois(1000,1)


test<- sim_data_for_one_trust(a,b)
test2<-gen_observed_data(test,0.2,1)
test3<-gen_wkly_total(test,daysinweek = 5)
test4<-gen_wkly_total(test2,daysinweek = 5)
l<-dim(test3)

test3$ha_P_lag1<-c(NA,test3$ha_P[1:(l-1)])
test3$ha_H_lag1<-c(NA,test3$ha_H[1:(l-1)])
test3$ca_P_lag1<-c(NA,test3$ca_P[1:(l-1)])

test4$o_ha_P_lag1<-c(NA,test4$o_ha_P[1:(l-1)])
test4$o_ha_H_lag1<-c(NA,test4$o_ha_H[1:(l-1)])
test4$o_ca_P_lag1<-c(NA,test4$o_ca_P[1:(l-1)])

lm(test3$ha_P ~ test3$ha_P_lag1)

glm(formula = ha_P ~ ha_P_lag1,data = test3, family = poisson(link = "identity"))

#  with data where cases are fully observed
glm.nb(formula = ha_P ~ ha_P_lag1,data = test3,link = "identity")
glm.nb(formula = ha_P ~ ha_P_lag1  + ha_H_lag1 ,data = test3,link = "identity",start=c(0.02,0.7,0.1))
glm.nb(formula = ha_P ~ ha_P_lag1  + ha_H_lag1 +  ca_P_lag1 ,data = test3,link = "identity",start=c(0.02,0.7,0.1,0.1))

#  with data where cases are partially observed
glm.nb(formula = o_ha_P ~ o_ha_P_lag1,data = test4,link = "identity")
glm.nb(formula = o_ha_P ~ o_ha_P_lag1  + o_ha_H_lag1 ,data = test4,link = "identity",start=c(0.02,0.7,0.1))
glm.nb(formula = o_ha_P ~ o_ha_P_lag1  + o_ha_H_lag1 +  o_ca_P_lag1 ,data = test4,link = "identity",start=c(0.02,0.7,0.1,0.1))


